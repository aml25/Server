/*pouch db interaction*/

var PouchDB = require("pouchdb");
var db = new PouchDB('http://localhost:5984/tunefarm');

//create a room or join an existing one
exports.joinRoom = function(roomName, _callback){
	db.get(roomName).then(function(doc){ //if the room already exists, then just return it for the client to join
		_callback(doc); //return the whole room "document" to the server
	}).catch(function(err){
		if(err.status=="404"){ //if the room doesn't exist, then create it and return to the client to join
			db.put({
				_id: roomName,
				room: roomName,
				tracks: [],
				currTrackIndex: 0,
				currTrackTime: 0,
				isPlaying: false,
				"public": false
			}).then(function(response){
				db.get(roomName).then(function(doc){
					_callback(doc); //return the whole room "document" to the server
				})
			}).catch(function(err){
				console.log(err);
			});
		}
	});
}

//duplicate the existing room and start a new one with a new name
exports.renameRoom = function(roomData, _callback){
	db.get(roomData.oldRoom).then(function(doc){
		var newDoc = JSON.parse(JSON.stringify(doc)); //this will copy the doc instead of reference it...
		
		newDoc['_id'] = roomData.room;
		newDoc.room = roomData.room;
		newDoc['public'] = true; //this is here temporarily - right now the assumption is if someone is changing a room name then they are making it public for the first time.  This is an incorrect assumption, but will have to do for now.
		db.put(newDoc); //duplicated JSON with needed changes for renaming

		db.remove(doc); //remove the old one

		_callback(newDoc); //return the whole room "document" to the server
	}).catch(function(err) {
		console.log(err);
	});
}

//add a track to the database, in the document for the current room
exports.addTrackToPlaylist = function(roomName, trackData, localUrl, _callback){
	db.get(roomName).then(function(doc){
		doc.tracks.push(
			{
				trackData: trackData,
				src: localUrl
			}
		); //add the track details to the database
		db.put(doc); //update the document

		_callback(doc);
	}).catch(function(err) {
		console.log(err);
	});
}

exports.getPlaylist = function(roomName, _callback){
	db.get(roomName).then(function(doc){
		_callback(doc);
	}).catch(function(err){
		console.log(err);
	});
}

exports.updateState = function(roomName, data, _callback){
	if(roomName != undefined){
		db.get(roomName).then(function(doc){
			for(var key in data){
				if(doc.hasOwnProperty(key)){
					doc[key] = data[key];
				}
			}

			db.put(doc); //update the document

			_callback(doc);
		}).catch(function(err){
			console.log(err);
		});
	}
}

exports.checkRoomStatus = function(roomName, _callback){
	db.get(roomName).then(function(doc){
		var status = doc.tracks.length > 0 ? true : false;
		if(status == false){
			db.remove(doc); //remove the room from the database if there are no tracks in the playlist. this is for regular cleanup
		}
		_callback(status);
	}).catch(function(err){
		console.log(err);
	});
}

exports.returnLiveRooms = function(_callback){
	var liveRooms = [];

	// create a design doc - has the mapping function to only get LIVE rooms from the database
	var ddoc = {
		_id: '_design/index',
		views: {
			"index": {
				map: function(doc){
						if(doc["public"] == true){
							emit(doc);
						}
					}.toString()
			}
		}
	}

	// put the design doc (and mapping function) in the database if it doesn't exist already
	db.put(ddoc).catch(function(err){
		if(err.status !== 409){
			throw err;
		}
	});

	db.query('index').then(function (results) {
		// handle result
		for(var room in results.rows){
			liveRooms.push(results.rows[room].key);
		}

		_callback(liveRooms);
	}).catch(function (err) {
		console.log(err);
	});

}







