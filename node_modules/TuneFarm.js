var TuneFarm = function(server){
	var self = this;
	self.path = require("path");
	self.dir = self.path.join(__dirname, "../public/TuneFarm"); //will this cause problems between local server testing and public server running?  For example the http location of the socket host for the client mismatch...
	self.musicDir = self.path.join(__dirname, "../TuneFarmMusic"); //the base directory for all music
	self.io = require("socket.io")(server);
	/*self.ionsp; //the namespace for this SOCKET.IO connection*/
	self.playMusic = require("playmusic");
	self.playMusic = new self.playMusic();
	self.fs = require("fs");
	self.config = JSON.parse(self.fs.readFileSync("config.json"));
	self.https = require("https");

	self.database;

	self.currRoom = "";

	self.playlist = []; //this is a dummy for testing

	//do any initial setup that's needed
	self.init = function(url){
		//console.log("new Tune Farm session");

		if(url.indexOf(".") > -1){
			//do nothing
		}
		else{
			/*console.log("setting up namespace for: " + url);
			self.ionsp = self.io.of(url);

			self.initIO();*/

			self.playMusic.init(self.config, function(err, response){
				if(err) console.error(err);
				console.log("starting a google play music session");
			});
		}
	}

	//generic function to handle all requests passed to TuneFarm
	self.handleRequest = function(req,res){
		/*console.log(req.url);
		console.log(req.query);*/

		//requesting an image
		if(req.url.indexOf("img/") > -1){
			//console.log("just requested: " + req.url.split("/").pop());
			var imgPath = self.path.join(self.dir + "/img/" + req.url.split("/").pop());
			//console.log("path: " + imgPath);
			res.sendFile(imgPath);
		}
		else if(req.url.indexOf("track/") > -1){
			console.log("returning a track");
			var trackPath = self.path.join(self.musicDir + "/" + req.url.split("/").pop());
			res.sendFile(trackPath);
		}
		else{
			res.sendFile(self.dir + "/index.html");
		}
	}

	
	/***HANDLE SOCKET COMMUNICATION*****************************************************************/
	//self.initIO = function(){
		self.io.on("connection",function(socket){
			console.log("hello new socket");

			//join some room
			socket.on("join", function(data){
				this.leave(self.currRoom);
				self.currRoom = data.room;
				console.log("joining " + self.currRoom);
				this.join(self.currRoom);
			});

			//handle searching for something
			socket.on("search", function(data){
				console.log("request: search");
				self.playMusic.search(data.query, 5, function(err, data){
					var data = data.entries.sort(function(a, b) { // sort by match score
						return a.score < b.score;
					});

					var artists = [];
					var albums = [];
					var tracks = [];

					for(var i=0;i<data.length;i++){
						switch(data[i].type){
							case '1': //track
								tracks.push(data[i].track);
								break;
							case '2': //artist
								artists.push(data[i].artist);
								break;
							case '3': //album
								albums.push(data[i].album);
								break;
						}
					}

					data = {
						artists: artists,
						albums: albums,
						tracks: tracks
					}

					socket.emit("searchResults", data);

				})
			});

			//handle artist request
			socket.on("getArtist", function(data){
				console.log("request: get artist");
				self.playMusic.getArtist(data.artistId, true, 4, 0, function(err, data){
					var artists = [];
					var albums = [];
					var tracks = [];

					artists.push(data);
					albums = data.albums;
					tracks = data.topTracks;

					data = {
						artists: artists,
						albums: albums,
						tracks: tracks
					}
					
					socket.emit("artistResults", data);
				});
			});

			//handle album request
			socket.on("getAlbum", function(data){
				console.log("request: get album");

				self.playMusic.getAlbum(data.albumId, true, function(err, data){
					var albums = [];
					var tracks = [];

					albums.push(data);
					tracks = data.tracks;

					data = {
						artists: null,
						albums: albums,
						tracks: tracks
					}

					socket.emit("albumResults", data);
				})
			});

			//handle track request
			socket.on("playTrack", function(data){
				console.log("request: play song");

				var data = data; //create a local copy of the track data for later functions

				//get track
				self.getTrack(data.storeId, function(){
					//download track?

					//return track URL *and* info
					socket.emit("playTrackResults", {src: "/track/"+data.storeId, trackData: data});
				});
			});

			socket.on("addTrackToPlaylist", function(data){
				console.log("request: add to playlist");

				var data = data; //create a local copy of the track data for later functions

				//get track
				self.getTrack(data.storeId, function(){
					self.playlist.push({ src: "/track/" + data.storeId + ".mp3", trackData: data});

					//do something for the client(s) as synced feedback?
					socket.emit("playlistResults", self.playlist);
				});
			});

			socket.on("getPlaylist", function(){
				socket.emit("playlistResults", self.playlist);
			})
		});
	//}
	/*****************************************************************HANDLE SOCKET COMMUNICATION***/

	self.getTrack = function(storeId, _callback){
		var _callback = _callback //create a local copy of the callback for later functions
		
		self.playMusic.getStreamUrl(storeId, function(err, res){
			var res = res; //create a local copy of the playMusic response for later functions

			var file = self.fs.createWriteStream(self.musicDir + "/" + storeId + ".mp3");
			var request = self.https.get(res, function(response) {
				response.pipe(file);

				_callback();
			});
		});
	}


}

module.exports = TuneFarm;